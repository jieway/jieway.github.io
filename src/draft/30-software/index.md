---
title: '《A Philosophy of Software Design》读书笔记之：如何降低软件复杂度'
date: '2024-05-25'
---

最近发现一本好书，《A Philosophy of Software Design》，这本书是关于如何使用复杂性来指导软件设计的整个生命周期。简单来说该书是在讲解软件开发中的复杂性是什么，如何降低复杂性。

中文版的名称是：软件设计的哲学。下面是中文版的开源地址：https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh

### 1. 什么是复杂性？

在编写程序的过程中，不同模块之间的依赖增多，复杂性不断积累。那么修改程序就需要考虑涉及到哪些相关模块，处理相关依赖，进而导致开发速度变慢。这个在开发的过程中是无法避免的，但是可以尽最大可能降低复杂性。

### 2. 如何规避复杂性？

通过设计简单的系统来降低复杂性。使用更简洁的代码，或者模块化，不对外暴露复杂性。

### 3. 在软件开发中为什么敏捷开发更流行，而非瀑布模型？

瀑布模型是将开发拆分为多个阶段，上一个阶段完成后才能完成下一个阶段，并且要保证在最初的设计阶段立即设计出来整个系统。这种方式在传统的建筑设计，工业中比较常见，因为一旦开始动工很多东西就定型了，变动起来没有那么容易。

而软件开发中，通常采用敏捷开发，而非瀑布模型。敏捷开发是指最初设计一个一部分，开发过程中根据遇到的现实问题进一步调整修改最初的设计。因为软件修改起来更容易，并且软件系统比较复杂，无法在一开始就能洞察所有的问题。

### 4. 敏捷开发有哪些问题？

敏捷开发是一种增量的形式，这意味着软件设计永远都不会完成，程序员要不断的重新设计，不断寻找能够改进系统的设计。

### 5. 什么是复杂性？

例如代码的工作流程很难理解、对代码进行小改动时需要耗费巨大的精力。简单来说如何软件很难理解和修改那么就是复杂的。

如果自己写的代码，其他阅读的人认为是复杂的，那么这段代码就是复杂的。此时需要搞清楚具体是哪些地方使得这段代码晦涩难懂，进而改进。程序员不仅仅要编写能够正常执行的代码，还要使其简单易懂。

### 6. 复杂性有哪些特点？

变更放大，例如修改数据时要修改多个地方。

认知负荷：开发需要学习很多的前置知识才能完成任务。例如 C/C++ 需要考虑内存分配，Java 不用考虑。

未知的未知：不知道自己不知道，直到错误出现之后才意识到自己不知道。

### 7. 哪些因素导致系统变的复杂？

依赖性和模糊性，例如修改一段代码需要考虑很多因素。解决办法时减少依赖关系的数量并且保持简单和明显。至于模糊性很多情况下是由于文档不足导致的。减少模糊性的最佳方法是简化系统设计。

### 8. 尽快的实现功能而不考虑良好的系统设计不可取

通常大部分的组织都系统尽快实现软件功能，这样会导致没有良好的系统设计。但这是短视的，虽然可以尽快完成任务，但是会导致软件复杂度增加，后续开发会变的逐渐困难。反之如果最初就花费时间设计最佳的系统，那么后续修改将会花费很少的时间。

简单来说不能为了尽快的完成任务而引入不必要的复杂性是得不偿失的，而花费时间设计简洁的系统架构更有价值。

### 9. 花费多少时间在系统设计上合适？

可以花费 10% - 20% 的时间来寻找更号的设计，相比于直接实现功能，初期进展会慢一些，但是后续会产生较大的收益。好的设计需要花费时间，这样可以确保小问题不会积累成大问题。

一个著名的例子就是 Facebook，在最初的时候强调以最快的速度实现功能即可，但是代码不稳定且难以理解，没有注释或测试。这样做导致后续发展很痛苦，后续鼓励员工花费更多的时间在系统设计上。

### 10. 简单的接口可以


######################################################




#### 7.3 装饰器
装饰器设计模式(也称为“包装器”)是一种鼓励跨层复制 API 的模式。装饰对象接受现有对象并扩展其功能;它提供一个与底层对象相似或相同的 API，它的方法调用底层对象的方法。在第 4 章的 Java I/O 示例中，BufferedInputStream 类是一个装饰器:给定一个 InputStream 对象，它提供了相同的 API，但是引入了缓冲。例如，当它的 read 方法被调用来读取单个字符时，它会调用底层 InputStream 上的 read 来读取更大的块，并保存额外的字符来满足未来的 read 调用。另一个例子出现在窗口系统中:Window 类实现了一个不能滚动的窗口的简单形式，而 ScrollableWindow 类通过添加水平和垂直滚动条来装饰窗口类。

装饰器的动机是将类的专用扩展与更通用的核心分开。但是，装饰器类往往很浅：它们引入了大量的样板，以实现少量的新功能。装饰器类通常包含许多直通方法。过度使用装饰器模式很容易，为每个小的新功能创建一个新类。这导致诸如 Java I/O 示例之类的浅层类激增。

创建装饰器类之前，请考虑以下替代方法：
- 您能否将新功能直接添加到基础类，而不是创建装饰器类？如果新功能是相对通用的，或者在逻辑上与基础类相关，或者如果基础类的大多数使用也将使用新功能，则这是有意义的。例如，几乎每个创建 Java InputStream 的人都会创建一个 BufferedInputStream，并且缓冲是 I/O 的自然组成部分，因此应该合并这些类。
- 如果新功能专用于特定用例，将其与用例合并而不是创建单独的类是否有意义？
- 您可以将新功能与现有的装饰器合并，而不是创建新的装饰器吗？这将导致一个更深的装饰器类，而不是多个浅的装饰器类。
最后，问问自己新功能是否真的需要包装现有功能：是否可以将其实现为独立于基类的独立类？在窗口示例中，滚动条可能与主窗口分开实现，而无需包装其所有现有功能。

有时装饰者很有意义，但通常有更好的选择

#### 7.4 接口与实现

“不同层，不同抽象”规则的另一个应用是，类的接口通常应与其实现不同：内部使用的表示形式应与接口中出现的抽象形式不同。如果两者具有相似的抽象，则该类可能不是很深。例如，在第 6 章讨论的文本编辑器项目中，大多数团队都以文本行的形式实现了文本模块，每行分别存储。一些团队还使用 getLine 和 putLine 之类的方法围绕行设计了文本类的 API。但是，这使文本类使用起来较浅且笨拙。在较高级别的用户界面代码中，通常在行中间插入文本（例如，当用户键入内容时）或删除跨行的文本范围。通过用于文本类的面向行的 API，调用者被迫拆分和合并行以实现用户界面操作。这段代码很简单，并且在用户界面的实现中被复制和散布。

文本类提供面向字符的接口时，使用起来要容易得多，例如，insert 方法可在文本的任意位置插入任意文本字符串（可能包括换行符），而 delete 方法则删除文本在文本中的两个任意位置之间。在内部，文本仍以行表示。面向字符的接口封装了文本类内部的行拆分和连接的复杂性，这使文本类更深，并简化了使用该类的高级代码。通过这种方法，文本 API 与面向行的存储机制大不相同。差异表示该类提供的有价值的功能

跨层 API 复制的另一种形式是传递变量，该变量是通过一长串方法向下传递的变量。图 7.2（a）显示了数据中心服务的示例。命令行参数描述用于安全通信的证书。只有底层方法 m3 才需要此信息，该方法调用一个库方法来打开套接字，但是该信息会通过 main 和 m3 之间路径上的所有方法向下传递。cert 变量出现在每个中间方法的签名中。

传递变量增加了复杂性，因为它们强制所有中间方法知道它们的存在，即使这些方法对变量没有用处。此外，如果存在一个新变量（例如，最初构建的系统不支持证书，但是您后来决定添加该支持），则可能必须修改大量的接口和方法才能将变量传递给所有相关路径。

消除传递变量可能具有挑战性。一种方法是查看最顶层和最底层方法之间是否已共享对象。在图 7.2 的数据中心服务示例中，也许存在一个对象，其中包含有关网络通信的其他信息，这对于 main 和 m3 都是可用的。如果是这样，main 可以将证书信息存储在该对象中，因此不必通过通往 m3 的路径上的所有干预方法来传递证书（请参见图 7.2（b））。但是，如果存在这样的对象，则它本身可能是传递变量（m3 还将如何访问它？）。

另一种方法是将信息存储在全局变量中，如图 7.2（c）所示。这避免了将信息从一个方法传递到另一个方法的需要，但是全局变量几乎总是会产生其他问题。例如，全局变量使得不可能在同一过程中创建同一系统的两个独立实例，因为对全局变量的访问会发生冲突。在生产中似乎不太可能需要多个实例，但是它们通常在测试中很有用。

我最常使用的解决方案是引入一个上下文对象，如图 7.2（d）所示。上下文存储应用程序的所有全局状态（否则将是传递变量或全局变量的任何状态）。大多数应用程序在其全局状态下具有多个变量，这些变量表示诸如配置选项，共享子系统和性能计数器之类的内容。每个系统实例只有一个上下文对象。上下文允许系统的多个实例在单个进程中共存，每个实例都有自己的上下文。

不幸的是，在许多地方可能都需要上下文，因此它有可能成为传递变量。为了减少必须意识到的方法数量，可以将上下文的引用保存在系统的大多数主要对象中。在图 7.2（d）的示例中，包含 m3 的类将对上下文的引用作为实例变量存储在其对象中。创建新对象时，创建方法将从其对象中检索上下文引用，并将其传递给新对象的构造函数。使用这种方法，上下文随处可见，但在构造函数中仅作为显式参数出现。

![UtlIHS.png](https://s1.ax1x.com/2020/07/13/UtlIHS.png)

>图 7.2：处理传递变量的可能技术。在（a）中，证书通过方法 m1 和 m2 传递，即使它们不使用它也是如此。在（b）中，main 和 m3 具有对一个对象的共享访问权，因此可以将变量存储在此处，而不用将其传递给 m1 和 m2。在（c）中，cert 存储为全局变量。在（d）中，证书与其他系统范围的信息（例如超时值和性能计数器）一起存储在上下文对象中；对上下文的引用存储在其方法需要访问它的所有对象中。

上下文对象统一了所有系统全局信息的处理，并且不需要传递变量。如果需要添加新变量，则可以将其添加到上下文对象；除了上下文的构造函数和析构函数外，现有代码均不受影响。由于上下文全部存储在一个位置，因此上下文可以轻松识别和管理系统的全局状态。上下文也便于测试：测试代码可以通过修改上下文中的字段来更改应用程序的全局配置。如果系统使用传递变量，则实施此类更改将更加困难。

上下文远非理想的解决方案。存储在上下文中的变量具有全局变量的大多数缺点。例如，为什么存在特定变量或在何处使用特定变量可能并不明显。没有纪律，上下文会变成巨大的数据抓包，从而在整个系统中创建不明显的依赖关系。上下文也可能产生线程安全问题；避免问题的最佳方法是使上下文中的变量不可变。不幸的是，我没有找到比上下文更好的解决方案。


#### 7.6 结论
接口，参数，函数，类或定义之类的添加到系统中的每个设计基础架构都会增加复杂性，因为开发人员必须了解该元素。为了使元素能够提供相对于复杂性的净收益，它必须消除在没有设计元素的情况下会出现的一些复杂性。否则，最好不要使用该特定元素来实施系统。例如，一个类可以通过封装功能来降低复杂性，以使该类的用户无需意识到这一点。

“不同的层，不同的抽象”规则只是此思想的一种应用：如果不同的层具有相同的抽象，例如直通方法或装饰器，则很有可能它们没有提供足够的利益来补偿它们代表的其他基础结构。类似地，传递参数要求几种方法中的每一种都知道它们的存在（这增加了复杂性），而又不提供其他功能。
