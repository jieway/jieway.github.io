{"componentChunkName":"component---src-templates-blog-post-js","path":"/cpp-summary/","result":{"data":{"site":{"siteMetadata":{"author":"weijiew","homeCity":"China"}},"markdownRemark":{"html":"<h2>1.0基础知识</h2>\n<p><strong>1.1：</strong></p>\n<p>编写c++程序一般经过<strong>编辑，编译，连接，运行</strong>四步。\n编辑：将<strong>c++源程序输入</strong>计算机的过程，文件名为<strong>cpp</strong>。\n编译：将cpp文件<strong>翻译成机器语言</strong>，文件名为<strong>obj</strong>。\n连接：<strong>分配内存地址</strong>后，转换成可执行程序，文件名为<strong>exe</strong>。\n运行：<strong>执行exe文件</strong>，将结果显示到屏幕上。\n<strong>1.2：</strong></p>\n<p>函数的返回值类型在定义之时就以决定。</p>\n<p><strong>1.3：</strong></p>\n<p>基类的公有成员采用私有继承时，在派生类中会变成私有成员。</p>\n<p><strong>1.4：</strong></p>\n<p>数据封装：将数据与操作封装到一起形成实体，这个实体也就是类。\n类也就是数据与操作的组合体，数据是类的静态特征，操作是类的动态特征。</p>\n<p><strong>1.5：</strong></p>\n<p>派生类是基类的扩展和延伸，派生类一个来自本体，一个来自基类。</p>\n<p><strong>1.6：</strong></p>\n<p>this指针可以保证每个对象都拥有自己的数据成员，可以共享处理这些数据的代码。</p>\n<p><strong>1.7：</strong></p>\n<p>多态分为静态多态和动态多态，静态多态是由于参数的不同调用同名函数，动态多态是由于对象的不同调用同名函数。多态的对象都是同名函数。</p>\n<p><strong>1.8：</strong></p>\n<p>内联函数代码量少，执行效率高，可以被频繁调用。也就是inline。</p>\n<p><strong>1.9：</strong></p>\n<p>派生类的调用顺序是先调用基类构造函数，调用子对象，在调用派生类。析构函数反之。</p>\n<p><strong>1.10</strong></p>\n<p>后置i++先赋值再自增，前置反之。</p>\n<p><strong>1.11</strong></p>\n<p>自身类对象不能作为类的成员，循环定义。</p>\n<p><strong>1.12</strong></p>\n<p>输出流的四种流 cin/cout/cerr/clog</p>\n<p><strong>1.13</strong></p>\n<p>类是对象的抽象，对象是类的实例。\n引用声明要初始化，指向存在的对象，初始化后就不能指向其他对象。</p>\n<p><strong>带默认形参值的函数</strong></p>\n<p>由默认值的形参必须在右边。\n又默认值的形参右不能出现无默认值的形参。\n因为在函数调用时是按从左至右的顺序建立对应关系的。\n不能重复定义</p>\n<h2>2.0函数例题</h2>\n<p><strong>八位二进制转十进制(教材习题3_2.cpp)</strong></p>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\ndouble power(double x,int n)\n{\n    double val=1.0,i;\n    for(i=0;i&#x3C;n;i++)\n        val*=x;\n    return val;\n}\nint main() \n{\n    int value=0;\n    cout&#x3C;&#x3C;\"Enter an 8 bit binary number:\";\n    for(int i=7;i>=0;i--)\n    {\n        char ch;\n        cin>>ch;\n        if(ch=='1')\n            value+=static_cast&#x3C;int>(power(2,i));//强制转换，把power（2，i）的结果由double型转换成int型。\n    }\n    cout&#x3C;&#x3C;\"Decimal value is\"&#x3C;&#x3C;value&#x3C;&#x3C;endl;\n    return 0;\n}\n</code></pre>\n<p><strong>编写程序求π值(教材习题3_3.cpp)</strong></p>\n<p>arctanx=x-x<em>x</em>x/3+x<em>x</em>x<em>x</em>x/5-…</p>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\ndouble arctan(double x)\n{\n    double sqr=x*x;\n    double e=x;\n    double r=0;\n    int i=1;\n    while(e/i>1e-5){\n        double f=e/i;\n        r=(i%4==1)?r+f:r-f;//判断i%4的结果是否等于1，若是1则r+f若不是1则r-f；\n        e=e*sqr;\n        i+=2;\n    }\n    return r；//注意\n}\nint main() {\n    double a=16.0*arctan(1/5.0);//整数相除结果取整若是1/5结果为0；\n    double b=4.0*arctan(1/239.0);\n    cout&#x3C;&#x3C;\"PI=\"&#x3C;&#x3C;a-b&#x3C;&#x3C;endl;\n    return 0;\n}\n</code></pre>\n<p><strong>寻找回文数(教材习题3_4.cpp)</strong></p>\n<p>思路：除10取余，取出每一位的数字。数字反置，低位充当高位，按反序构成新的数，与原数比较。</p>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\nbool symm(unsigned n)//判断是否为回文数\n{\n    unsigned i=n;\n    unsigned m=0;\n    **while(i>0)\n    {\n        m=m*10+i%10;\n        i/=10;\n    }**\n    return m==n;//函数为bool类型，所以返回值类型也是bool类型，如果m==n为返回true，反之为false。\n    }\nint main() \n{\n    for(unsigned m=11;m&#x3C;1000;m++)\n    if(symm(m)&#x26;&#x26;symm(m*m)&#x26;&#x26;symm(m*m*m))\n    {\n        cout&#x3C;&#x3C;\"m=\"&#x3C;&#x3C;m;\n        cout&#x3C;&#x3C;\"m*m=\"&#x3C;&#x3C;m*m;\n        cout&#x3C;&#x3C;\"m*m*m=\"&#x3C;&#x3C;m*m*m&#x3C;&#x3C;endl;\n    }\n    return 0;\n}\n</code></pre>\n<p> <strong>教材习题3_5.cpp</strong></p>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\n#include&#x3C;cmath>\nusing namespace std;\nconst double TINY_VALUE=1e-10;//定义一个常量\ndouble tsin(double x)//实现sin函数\n{\n    double g=0;\n    double t=x;\n    int n=1;\n    do{\n        g+=t;\n        n++;\n        t=-t*x*x/(2*n-1)/(2*n-2);//阶乘的实现\n    }while(fabs(t)>=TINY_VALUE);\n    return g;\n}\nint main() \n{\n    double k,r,s;\n    cout&#x3C;&#x3C;\"r=\";\n    cin>>r;\n    cout&#x3C;&#x3C;\"s=\";\n    cin>>s;\n    if(r*r&#x3C;=s*s)\n        k=sqrt(tsin(r)*tsin(r)+tsin(s)*tsin(s));\n    else\n        k=tsin(r*s)/2;\n    cout&#x3C;&#x3C;k&#x3C;&#x3C;endl;\n    return 0;\n}\n</code></pre>\n<p><strong>总结：</strong> </p>\n<p>const优点\n1定义一个常量，不可变性。\n2便于检查，消除隐患。\n3总控制\n4节省空间\n5提高效率，编译器不提供内存空间，而是将它保存在符号表中。</p>\n<p> <strong>例3-7</strong></p>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\nint fu2(int m)//fu1 fu2 顺序不能反。\n{\n    return m*m;\n}\nint fu1(int x,int y)\n{\n    return fu2(x)+fu2(y);\n}\n\nint main()\n{\n    int a,b;\n    cin>>a>>b;\n    cout&#x3C;&#x3C;fu1(a,b)&#x3C;&#x3C;endl;\n    return 0;\n}\n</code></pre>\n<p><strong>例3-8</strong></p>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\nunsigned fac(unsigned n)\n{\n    unsigned f;\n        if(n==0)\n            f=1;\n        else\n            f=fac(n-1)*n;//循环再次进入fac 函数\n        return f;\n}\nint main() \n{\n    int a;\n    cin>>a;\n    cout&#x3C;&#x3C;fac(a)&#x3C;&#x3C;endl;\n    return 0;\n}\n</code></pre>\n<p><strong>例3-9</strong></p>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\nint comm(int n,int k)\n{\n    if(k>n)\n        return 0;\n    else if(n==k||k==0)\n        return 1;\n    else \n        return comm(n-1,k)+comm(n-1,k-1);//分好类\n}\nint main()\n{\n    int n,k;\n    cout&#x3C;&#x3C;\"Please enter two integers n and k:\";\n    cin>>n>>k;\n    cout&#x3C;&#x3C;\"C(n,k)=\"&#x3C;&#x3C;comm(n,k)&#x3C;&#x3C;endl;\n    return 0;\n}\n</code></pre>\n<p><strong>值传递与引用传递</strong></p>\n<pre><code class=\"language-cpp\">void swap（int a，int b）\n</code></pre>\n<pre><code class=\"language-cpp\">void swap （int &#x26;a，int &#x26;b）\n</code></pre>\n<p>形参写法不同，效果虽同，但差异很大。</p>\n<p>引用声明要初始化，指向存在的对象，初始化后就不能指向其他对象。</p>\n<h2>3.0内联函数</h2>\n<p><strong>3.1</strong>内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。</p>\n<p><strong>3.2</strong>节省参数传递，控制转移开销。inline 只是一个要求，没有inline，在现代编译器中也可能被认为是内联函数。</p>\n<p><strong>4.0带默认形参值的函数</strong></p>\n<p><strong>4.1</strong>由默认值的形参必须在右边。</p>\n<p><strong>4.2</strong>又默认值的形参右不能出现无默认值的形参。</p>\n<p><strong>4.3</strong>因为在函数调用时是按从左至右的顺序建立对应关系的。</p>\n<p><strong>4.4</strong>不能重复定义</p>\n<h2>闰年</h2>\n<pre><code>    if((a%4==0&#x26;&#x26;a%100!=0)||(a%400==0));\n</code></pre>\n<h2>switch语句的用法</h2>\n<pre><code class=\"language-cpp\">switch(day)\n{\ncase 0:\n    cout&#x3C;&#x3C;\" \"&#x3C;&#x3C;endl;break;\ncase 1：\n    cout&#x3C;&#x3C;\" \"&#x3C;&#x3C;endl;break;  \n}\n</code></pre>\n<h2>while do/while for语句的用法</h2>\n<h2>数字反转</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\nint main()\n{\n    int n,a,b;\n    cin>>n;\n    do\n    {\n        a=n%10;\n        cout&#x3C;&#x3C;a;\n        n/=10;\n    }while(n!=0);\n    cout&#x3C;&#x3C;sum;\n    return 0;\n}\n</code></pre>\n<p>求数字的因子\n因子：从1到n，凡是可以整除n的数字均为n的因子</p>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\nint main()\n{\n    int n,a,b;\n    cin>>n;\n    for(int i=1;i&#x3C;=n;i++)//遍历n\n    {\n        if(n%i==0)\n            cout&#x3C;&#x3C;i&#x3C;&#x3C;\" \";\n    }\n    cout&#x3C;&#x3C;endl;\n    return 0;\n}\n</code></pre>\n<p>九九乘法表</p>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\nint main()\n{\n    for(int i=1;i&#x3C;10;i++)\n    {\n        for(int j=1;j&#x3C;=i;j++)\n        {\n            cout&#x3C;&#x3C;j&#x3C;&#x3C;\"*\"&#x3C;&#x3C;i&#x3C;&#x3C;\"=\"&#x3C;&#x3C;i*j&#x3C;&#x3C;\" \";\n        }\n            cout&#x3C;&#x3C;endl;\n    }\n    return 0;\n}\n</code></pre>\n<p>8-1</p>\n<pre><code class=\"language-cpp\">#include &#x3C;iostream>\nusing namespace std;\nclass co{\npublic:\n    co (double r=0.0,double i=0.0)\n    {\n        a=r;\n        b=i;\n    }\n    co operator+(const co &#x26;c2) const{\n    return co(a+c2.a,b+c2.b);\n};\n    co operator-(const co &#x26;c2) const{\n    return co(a-c2.a,b-c2.b);\n};\n    void display() const{\n    cout&#x3C;&#x3C;\"(\"&#x3C;&#x3C;a&#x3C;&#x3C;\",\"&#x3C;&#x3C;b&#x3C;&#x3C;\")\"&#x3C;&#x3C;endl;\n};\nprivate:\n    double a;\n    double b;\n};\n/*co co::operator+(const co &#x26;c2) const{\n    return co(a+c2.a,b+c2.b);\n}\nco co::operator-(const co &#x26;c2) const{\n    return co(a-c2.a,b-c2.b);\n}\nvoid co::display() const{\n    cout&#x3C;&#x3C;\"(\"&#x3C;&#x3C;a&#x3C;&#x3C;\",\"&#x3C;&#x3C;b&#x3C;&#x3C;\")\"&#x3C;&#x3C;endl;\n}*/\nint main()\n{\n    co c1(5,4),c2(2,10),c3;\n    c1.display();\n    c2.display();\n    c3=c1-c2;\n    c3.display();\n    c3=c1+c2;\n    c3.display();\n    return 0;\n}\n</code></pre>\n<pre><code class=\"language-cpp\">#include &#x3C;iostream>\nusing namespace std;\nclass co{\npublic:\n    co (double r=0.0,double i=0.0)\n    {\n        a=r;\n        b=i;\n    }\n    co operator+(const co &#x26;c2) const;\n    co operator-(const co &#x26;c2) const;\n    void display() const;\nprivate:\n    double a;\n    double b;\n};\nco co::operator+(const co &#x26;c2) const{\n    return co(a+c2.a,b+c2.b);\n}\nco co::operator-(const co &#x26;c2) const{\n    return co(a-c2.a,b-c2.b);\n}\nvoid co::display() const{\n    cout&#x3C;&#x3C;\"(\"&#x3C;&#x3C;a&#x3C;&#x3C;\",\"&#x3C;&#x3C;b&#x3C;&#x3C;\")\"&#x3C;&#x3C;endl;\n}\nint main()\n{\n    co c1(5,4),c2(2,10),c3;\n    c1.display();\n    c2.display();\n    c3=c1-c2;\n    c3.display();\n    c3=c1+c2;\n    c3.display();\n    return 0;\n}\n</code></pre>\n<p>8-4</p>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\nclass base1{\npublic:\n    virtual void display() const;\n};\nvoid base1::display()const{\n    cout&#x3C;&#x3C;\"base::display()\"&#x3C;&#x3C;endl;\n}\nclass base2:public base1{\npublic:\n    void display()const;\n};\nvoid base2::display()const{\n    cout&#x3C;&#x3C;\"base2::display()\"&#x3C;&#x3C;endl;\n}\nclass derived:public base2{\npublic:\n    void display()const;\n};\nvoid derived::display()const{\n    cout&#x3C;&#x3C;\"derived::display()\"&#x3C;&#x3C;endl;\n} \nvoid fun(base1*ptr)\n{\n    ptr->display();\n}\nint main()\n{\n    base1 base1;\n    base2 base2;\n    derived derived;\n    fun(&#x26;base1);\n    fun(&#x26;base2);\n    fun(&#x26;derived);\n    return 0;\n}\n</code></pre>\n<p>9-1函数模板</p>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\ntemplate&#x3C;class t>\nvoid qq(t *a,int i)\n{\n    for(int j=0;j&#x3C;i;j++)\n        cout&#x3C;&#x3C;a[j]&#x3C;&#x3C;\" \";\n    cout&#x3C;&#x3C;endl;\n}\nint main()\n{\n    int a[5]={0,1,2,3,4};\n    double b[5]={0.5,0.1,0.2,0.3,0.4};\n    qq(a,5);\n    qq(b,5);\n    return 0;\n}\n</code></pre>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\ntemplate&#x3C;class t>\nt abs(t x)\n{\n    return x&#x3C;0?-x,:x;\n}\nint main()\n{\n    int i;\n    cin>>i;\n    cout&#x3C;&#x3C;abs(i)&#x3C;&#x3C;endl;\n    return 0;\n}\n</code></pre>\n<p>8-5</p>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\nclass base\n{\npublic:\n    virtual~base();\n};\nbase::~base()\n{\n    cout&#x3C;&#x3C;\"base destructor\"&#x3C;&#x3C;endl;\n}\nclass derived:public base\n{\npublic:\n    derived();\n    ~derived();\nprivate:\n    int *p;\n};\nderived::derived(){\n    p=new int(0);\n}\nderievd::~derievd(){\n            cout&#x3C;&#x3C;\"derievd destructor\"&#x3C;&#x3C;endl;\n            delete p;\n}\n        void fun(base*b)\n        {\n            delete b;\n        }\n        int main()\n        {\n            base*b=new derived();\n            fun(b);\n            return 0;\n        }\n</code></pre>\n<h2>7-5</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;iostream>\nusing namespace std;\nclass base1\n{\npublic:\n    base1(int i){}\n    ~base1(){}\n};\nclass base2\n{\npublic:\n    base2(int j){}\n    ~base2(){}\n};\nclass base3\n{\npublic:\n    base3(){}\n    ~base3(){}\n};\nclass derived:public base2,public base1,public base3{\npublic:\n    derived(int a,int b,int c,int d):base1(a),member2(d),member1(c),base2(b){}\nprivate:\n    base1 member1;\n    base2 member2;\n    base3 member3;\n};\nint main()\n{\n    derived obj(1,2,3,4);\n    return 0;\n}\n</code></pre>\n<p>摸球问题</p>\n<pre><code class=\"language-cpp\">#include &#x3C;iostream>\nusing namespace std;\nint main()\n{\nint i,j,k;\nint sum;\nsum=0;\nfor(i=1;i&#x3C;5;i++)\nfor(j=1;j&#x3C;5;j++)\nfor(k=1;k&#x3C;5;k++)\n{\nif(i!=j &#x26;&#x26; j!=k &#x26;&#x26;i!=k)\n{sum=sum+1;}\n}\ncout&#x3C;&#x3C;sum;\n}\n</code></pre>","excerpt":"1.0基础知识 1.1： 编写c++程序一般经过编辑，编译，连接，运行四步。\n编辑：将c++源程序输入计算机的过程，文件名为cpp。\n编译：将cpp文件翻译成机器语言，文件名为obj。\n连接：分配内存地址后，转换成可执行程序，文件名为exe。\n运行：执行exe…","fields":{"tagSlugs":["/tags/cpp/"]},"frontmatter":{"title":"CPP 期末总结","tags":["CPP"],"date":"December 18, 2018"}}},"pageContext":{"slug":"/cpp-summary/"}}}