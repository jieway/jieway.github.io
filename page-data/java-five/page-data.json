{"componentChunkName":"component---src-templates-blog-post-js","path":"/java-five/","result":{"data":{"site":{"siteMetadata":{"author":"weijiew","homeCity":"China"}},"markdownRemark":{"html":"<h2>五子棋</h2>\n<p><strong>主方法</strong></p>\n\n        <deckgo-highlight-code   >\n          <code slot=\"code\">\tpublic static void main(String[] args) {\n\t\tnew FiveGame();\n\t}\t</code>\n        </deckgo-highlight-code>\n      \n<p><strong>FiveGame</strong></p>\n\n        <deckgo-highlight-code   >\n          <code slot=\"code\">\tpublic FiveGame(){\n\t\tthis.setTitle(&quot;五子棋1.0&quot;);\n\t\tthis.setSize(500,500);\n\t\tthis.setLocation((width - 500) / 2 , (height - 500) / 2 );\n\t\tthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tthis.setResizable(false);  //设置窗口不可改变，固定窗口大小\n\t\tthis.setVisible(true);\n\t\t\n\t\tthis.repaint();  //java里repaint()是重绘component的方法；\n\t\tthis.addMouseListener(this);\n \n\t\t\n\t}</code>\n        </deckgo-highlight-code>\n      \n<p><strong>画棋盘</strong></p>\n\n        <deckgo-highlight-code   >\n          <code slot=\"code\">\tpublic void paint(Graphics g){\n\t\tBufferedImage buf = new BufferedImage(500, 500, BufferedImage.TYPE_INT_RGB);\n\t\tGraphics g1 =  buf.createGraphics();  // 创建画笔\n\t\tg1.setColor(new Color(0,169,158));\n\t\tg1.fill3DRect(43, 60, 375, 375, true);\n\t\t\tfor (int i = 0; i &lt;= 15; i++) {\n\t\t\t\tg1.setColor(Color.WHITE);\n\t\t\t\tg1.drawLine(43, 60+i*25, 375+43, 60+i*25);  //画棋盘横线\n\t\t\t\tg1.drawLine(43+i*25, 60, 43+i*25, 375+60);  //画棋盘竖线\n\t\t\t}\t        \n\t\t        for(int i=0; i&lt;15; i++){\n\t\t\t\tfor (int j = 0; j &lt; 15; j++) {\n\t\t\t\t\t//画实心黑子\n\t\t\t\t\tif(allChess[i][j] == 1){    \n\t\t\t\t\t\tint tempX = i*25+47;\n\t\t\t\t\t\tint tempY = j*25+64;\n\t\t\t\t\t\tg1.setColor(Color.BLACK);\n\t\t\t\t\t\tg1.fillOval(tempX, tempY, 16, 16);\n\t\t\t\t\t\tg1.setColor(Color.BLACK);\n\t\t\t\t\t\tg1.drawOval(tempX, tempY, 16, 16);\n\t\t\t\t\t}\n\t\t\t\t\t//画实心白子\n\t\t\t\t\tif(allChess[i][j] == 2){\n\t\t\t\t\t\tint tempX = i*25+47;\n\t\t\t\t\t\tint tempY = j*25+64;\n\t\t\t\t\t\tg1.setColor(Color.WHITE);\n\t\t\t\t\t\tg1.fillOval(tempX, tempY, 16, 16);\n\t\t\t\t\t\tg1.setColor(Color.WHITE);\n\t\t\t\t\t\tg1.drawOval(tempX, tempY, 16, 16);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\t g.drawImage(buf, 0, 0,this);\t\n\t}</code>\n        </deckgo-highlight-code>\n      \n<p><strong>鼠标监听器</strong></p>\n\n        <deckgo-highlight-code   >\n          <code slot=\"code\">\tpublic void mousePressed(MouseEvent e){\n\t\tif(canPlay){\n\t\t\tx=e.getX();\n\t\t\ty=e.getY();  // 用来获取鼠标坐标\n\t\t\tif(x&gt;55 &amp;&amp; x&lt;= 405  &amp;&amp; y&gt;=72 &amp;&amp; y&lt;=420){\n\t\t\t\t//让鼠标在棋盘范围内\n\t\t\t\tif((x-55)%25&gt;12){\n\t\t\t\t\tx=(x-55)/25 + 1;\n\t\t\t\t}else {\n\t\t\t\t\tx = (x-55)/25;\n\t\t\t\t}\n\t\t\t\tif((y-72)%25&gt;12){\n\t\t\t\t\ty=(y-72)/25 + 1;\n\t\t\t\t}else {\n\t\t\t\t\ty=(y-72)/25;\n\t\t\t\t}\t\n\t\t\t\t//落子\n\t\t\t\tif(allChess[x][y] == 0){\n\t\t\t\t\tchessX[countX++] = x;\n\t\t\t\t\tchessY[countY++] = y;\n\t\t\t\t\tif(isblack){\n\t\t\t\t\t\tallChess[x][y] = 1;\n\t\t\t\t\t\tisblack = false;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tallChess[x][y] = 2;\n\t\t\t\t\t\tisblack = true;\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tthis.repaint();\t\t\n\t\t\t\t\tif(this.isWin()){\n\t\t\t\t\t\tif(allChess[x][y] == 1){\n\t\t\t\t\t\t\tJOptionPane.showMessageDialog(this, &quot;游戏结束，黑方胜利&quot;);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tJOptionPane.showMessageDialog(this, &quot;游戏结束，白方胜利&quot;);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.canPlay = false;  //表示游戏结束\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}</code>\n        </deckgo-highlight-code>\n      \n<p><strong>判断方向</strong></p>\n\n        <deckgo-highlight-code   >\n          <code slot=\"code\">\tpublic boolean isWin(){\n\t\tboolean flag = false;\n\t\tint count = 1;  //用来保存共有相同颜色多少棋子相连，初始值为1\n\t\tint color = allChess[x][y];  //color = 1 (黑子) color = 2(白子)\n\t\t\n\t\t//判断横向是否有5个棋子相连，特点:纵坐标是相同，即allChess[x][y] 中y值是相同\n\t\tcount = this.checkCount(1,0,color);\n\t\tif(count &gt;= 5){\n\t\t\tflag = true;\n\t\t}else {\n\t\t\t//判断纵向\n\t\t\tcount = this.checkCount(0,1,color);\n\t\t\tif(count &gt;= 5){\n\t\t\t\tflag = true;\n\t\t\t}else {\n\t\t\t\t //判断右上,左下\n\t\t\t\tcount = this.checkCount(1,-1,color);\n\t\t\t\tif(count &gt;= 5){\n\t\t\t\t\tflag = true;\n\t\t\t\t}else {\n\t\t\t\t\t//判断右下,左上\n\t\t\t\t\tcount = this.checkCount(1,1,color);\n\t\t\t\t\tif(count &gt;= 5){\n\t\t\t\t\t\tflag =  true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}</code>\n        </deckgo-highlight-code>\n      \n<p><strong>判断一个五子连线</strong></p>\n\n        <deckgo-highlight-code   >\n          <code slot=\"code\">\tpublic int checkCount(int xChange , int yChenge ,int color){\n\t\tint count = 1;\n\t\tint tempX = xChange;\n\t\tint tempy = yChenge;  //保存初始值\t\n\t\t//全局变量x,y最初为鼠标点击的坐标，\n\t\t//经下棋方法已经x,y的将范围变成0-15(遍历整个棋盘,寻找相同颜色的棋子)\n\t\twhile(x + xChange &gt;=0 &amp;&amp; x+xChange &lt;15  &amp;&amp; y+yChenge &gt;=0 &amp;&amp; y+yChenge &lt; 15 &amp;&amp; color == allChess[x+xChange][y+yChenge]){\n\t\t\tcount++;\n\t\t\tif(xChange != 0)  xChange++;    \n\t\t\tif(yChenge != 0 ){      \n\t\t\t\tif(yChenge != 0){\n\t\t\t\t\tif(yChenge &gt; 0) {   \n\t\t\t\t\t\tyChenge++;\t\t\n\t\t\t\t\t}else {\n\t\t\t\t\t\tyChenge--;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t\txChange = tempX;\n\t\tyChenge = tempy;   // 恢复初始值\t\t\t\t\n\t\twhile(x-xChange &gt;=0 &amp;&amp; x-xChange &lt;15 &amp;&amp; y-yChenge &gt;=0 &amp;&amp;\n\t\t\t\ty-yChenge &lt;15 &amp;&amp; color == allChess[x-xChange][y-yChenge]){\t\t\n\t\t\tcount++;\n\t\t\tif(xChange != 0){\n\t\t\t\txChange++;\n\t\t\t}\n\t\t\tif(yChenge != 0){\n\t\t\t\tif (yChenge &gt; 0) {\n\t\t\t\t\tyChenge++;\t\t\t\n\t\t\t\t}else {\n\t\t\t\t\tyChenge--;\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\treturn count;\n\t}\t\t</code>\n        </deckgo-highlight-code>\n      \n\n        <deckgo-highlight-code   >\n          <code slot=\"code\">package 模拟练习.五子棋;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport java.awt.*;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.image.BufferedImage;\npublic  class FiveGame extends JFrame implements MouseListener{\n\tint width = Toolkit.getDefaultToolkit().getScreenSize().width;\n\tint height = Toolkit.getDefaultToolkit().getScreenSize().height;\n\tint x,y;  // 定义鼠标的坐标\n\tint[][] allChess = new int[15][15];   // 用数组来保存棋子，0表示无子，1表示黑子，2表示白子\n\tboolean isblack = true;   //用来表示黑子还是白子， true表示黑子   false表示白子\n\tboolean canPlay = true;   // 用来表示当前游戏是否结束\n\t\n\tint[] chessX = new int[255];\n\tint[] chessY = new int[255];\n\tint countX,countY;\n        \n\tpublic FiveGame(){\n\t\tthis.setTitle(&quot;五子棋1.0&quot;);\n\t\tthis.setSize(500,500);\n\t\tthis.setLocation((width - 500) / 2 , (height - 500) / 2 );\n\t\tthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tthis.setResizable(false);  //设置窗口不可改变，固定窗口大小\n\t\tthis.setVisible(true);\n\t\t\n\t\tthis.repaint();  //java里repaint()是重绘component的方法；\n\t\tthis.addMouseListener(this);\t\t\n\t}\n\tpublic void paint(Graphics g){\n\t\tBufferedImage buf = new BufferedImage(500, 500, BufferedImage.TYPE_INT_RGB);\n\t\tGraphics g1 =  buf.createGraphics();  // 创建画笔\n\t\tg1.setColor(new Color(135,206,250));\n\t\tg1.fill3DRect(43, 60, 375, 375, true);\n\t\t\tfor (int i = 0; i &lt;= 15; i++) {\n\t\t\t\tg1.setColor(Color.WHITE);\n\t\t\t\tg1.drawLine(43, 60+i*25, 375+43, 60+i*25);  //画棋盘横线\n\t\t\t\tg1.drawLine(43+i*25, 60, 43+i*25, 375+60);  //画棋盘竖线\n\t\t\t}\t        \n\t\t        for(int i=0; i&lt;15; i++){\n\t\t\t\tfor (int j = 0; j &lt; 15; j++) {\n\t\t\t\t\t//画实心黑子\n\t\t\t\t\tif(allChess[i][j] == 1){    \n\t\t\t\t\t\tint tempX = i*25+47;\n\t\t\t\t\t\tint tempY = j*25+64;\n\t\t\t\t\t\tg1.setColor(Color.BLACK);\n\t\t\t\t\t\tg1.fillOval(tempX, tempY, 16, 16);\n\t\t\t\t\t\tg1.setColor(Color.BLACK);\n\t\t\t\t\t\tg1.drawOval(tempX, tempY, 16, 16);\n\t\t\t\t\t}\n\t\t\t\t\t//画实心白子\n\t\t\t\t\tif(allChess[i][j] == 2){\n\t\t\t\t\t\tint tempX = i*25+47;\n\t\t\t\t\t\tint tempY = j*25+64;\n\t\t\t\t\t\tg1.setColor(Color.WHITE);\n\t\t\t\t\t\tg1.fillOval(tempX, tempY, 16, 16);\n\t\t\t\t\t\tg1.setColor(Color.WHITE);\n\t\t\t\t\t\tg1.drawOval(tempX, tempY, 16, 16);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\t g.drawImage(buf, 0, 0,this);\t\n\t}\n\tpublic void mousePressed(MouseEvent e){\n\t\tif(canPlay){\n\t\t\tx=e.getX();\n\t\t\ty=e.getY();  // 用来获取鼠标坐标\n\t\t\tif(x&gt;55 &amp;&amp; x&lt;= 405  &amp;&amp; y&gt;=72 &amp;&amp; y&lt;=420){\n\t\t\t\t//让鼠标在棋盘范围内\n\t\t\t\tif((x-55)%25&gt;12){\n\t\t\t\t\tx=(x-55)/25 + 1;\n\t\t\t\t}else {\n\t\t\t\t\tx = (x-55)/25;\n\t\t\t\t}\n\t\t\t\tif((y-72)%25&gt;12){\n\t\t\t\t\ty=(y-72)/25 + 1;\n\t\t\t\t}else {\n\t\t\t\t\ty=(y-72)/25;\n\t\t\t\t}\t\n\t\t\t\t//落子\n\t\t\t\tif(allChess[x][y] == 0){\n\t\t\t\t\tchessX[countX++] = x;\n\t\t\t\t\tchessY[countY++] = y;\n\t\t\t\t\tif(isblack){\n\t\t\t\t\t\tallChess[x][y] = 1;\n\t\t\t\t\t\tisblack = false;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tallChess[x][y] = 2;\n\t\t\t\t\t\tisblack = true;\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tthis.repaint();\t\t\n\t\t\t\t\tif(this.isWin()){\n\t\t\t\t\t\tif(allChess[x][y] == 1){\n\t\t\t\t\t\t\tJOptionPane.showMessageDialog(this, &quot;游戏结束，黑方胜利&quot;);\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tJOptionPane.showMessageDialog(this, &quot;游戏结束，白方胜利&quot;);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.canPlay = false;  //表示游戏结束\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}\n\tpublic boolean isWin(){\n\t\tboolean flag = false;\n\t\tint count = 1;  //用来保存共有相同颜色多少棋子相连，初始值为1\n\t\tint color = allChess[x][y];  //color = 1 (黑子) color = 2(白子)\n\t\t\n\t\t//判断横向是否有5个棋子相连，特点:纵坐标是相同，即allChess[x][y] 中y值是相同\n\t\tcount = this.checkCount(1,0,color);\n\t\tif(count &gt;= 5){\n\t\t\tflag = true;\n\t\t}else {\n\t\t\t//判断纵向\n\t\t\tcount = this.checkCount(0,1,color);\n\t\t\tif(count &gt;= 5){\n\t\t\t\tflag = true;\n\t\t\t}else {\n\t\t\t\t //判断右上,左下\n\t\t\t\tcount = this.checkCount(1,-1,color);\n\t\t\t\tif(count &gt;= 5){\n\t\t\t\t\tflag = true;\n\t\t\t\t}else {\n\t\t\t\t\t//判断右下,左上\n\t\t\t\t\tcount = this.checkCount(1,1,color);\n\t\t\t\t\tif(count &gt;= 5){\n\t\t\t\t\t\tflag =  true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag;\n\t}\n\tpublic int checkCount(int xChange , int yChenge ,int color){\n\t\tint count = 1;\n\t\tint tempX = xChange;\n\t\tint tempy = yChenge;  //保存初始值\t\n\t\t//全局变量x,y最初为鼠标点击的坐标，\n\t\t//经下棋方法已经x,y的将范围变成0-15(遍历整个棋盘,寻找相同颜色的棋子)\n\t\twhile(x + xChange &gt;=0 &amp;&amp; x+xChange &lt;15  &amp;&amp; y+yChenge &gt;=0 &amp;&amp; y+yChenge &lt; 15 &amp;&amp; color == allChess[x+xChange][y+yChenge]){\n\t\t\tcount++;\n\t\t\tif(xChange != 0)  xChange++;    \n\t\t\tif(yChenge != 0 ){      \n\t\t\t\tif(yChenge != 0){\n\t\t\t\t\tif(yChenge &gt; 0) {   \n\t\t\t\t\t\tyChenge++;\t\t\n\t\t\t\t\t}else {\n\t\t\t\t\t\tyChenge--;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t\txChange = tempX;\n\t\tyChenge = tempy;   // 恢复初始值\t\t\t\t\n\t\twhile(x-xChange &gt;=0 &amp;&amp; x-xChange &lt;15 &amp;&amp; y-yChenge &gt;=0 &amp;&amp;\n\t\t\t\ty-yChenge &lt;15 &amp;&amp; color == allChess[x-xChange][y-yChenge]){\t\t\n\t\t\tcount++;\n\t\t\tif(xChange != 0){\n\t\t\t\txChange++;\n\t\t\t}\n\t\t\tif(yChenge != 0){\n\t\t\t\tif (yChenge &gt; 0) {\n\t\t\t\t\tyChenge++;\t\t\t\n\t\t\t\t}else {\n\t\t\t\t\tyChenge--;\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\treturn count;\n\t}\t\t\n\tpublic void mouseClicked(MouseEvent e) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\tpublic void mouseReleased(MouseEvent e) {\n\t\t// TODO Auto-generated method stub\n\t}\n\tpublic void mouseEntered(MouseEvent e) {\n\t\t// TODO Auto-generated method stub\n\t}\n\tpublic void mouseExited(MouseEvent e) {\n\t\t// TODO Auto-generated method stub\t\t\n\t}\t\n\tpublic static void main(String[] args) {\n\t\tnew FiveGame();\n\t}\t\n}</code>\n        </deckgo-highlight-code>\n      ","excerpt":"五子棋 主方法 FiveGame 画棋盘 鼠标监听器 判断方向 判断一个五子连线","fields":{"tagSlugs":["/tags/java/"]},"frontmatter":{"title":"Java-五子棋","tags":["Java"],"date":"May 04, 2019"}}},"pageContext":{"slug":"/java-five/"}}}