{"componentChunkName":"component---src-templates-blog-post-js","path":"/java-five/","result":{"data":{"site":{"siteMetadata":{"author":"weijiew","homeCity":"China"}},"markdownRemark":{"html":"<h2>五子棋</h2>\n<p><strong>主方法</strong></p>\n<pre><code>    public static void main(String[] args) {\n        new FiveGame();\n    }   \n</code></pre>\n<p><strong>FiveGame</strong></p>\n<pre><code>    public FiveGame(){\n        this.setTitle(\"五子棋1.0\");\n        this.setSize(500,500);\n        this.setLocation((width - 500) / 2 , (height - 500) / 2 );\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setResizable(false);  //设置窗口不可改变，固定窗口大小\n        this.setVisible(true);\n        \n        this.repaint();  //java里repaint()是重绘component的方法；\n        this.addMouseListener(this);\n \n        \n    }\n</code></pre>\n<p><strong>画棋盘</strong></p>\n<pre><code>    public void paint(Graphics g){\n        BufferedImage buf = new BufferedImage(500, 500, BufferedImage.TYPE_INT_RGB);\n        Graphics g1 =  buf.createGraphics();  // 创建画笔\n        g1.setColor(new Color(0,169,158));\n        g1.fill3DRect(43, 60, 375, 375, true);\n            for (int i = 0; i &#x3C;= 15; i++) {\n                g1.setColor(Color.WHITE);\n                g1.drawLine(43, 60+i*25, 375+43, 60+i*25);  //画棋盘横线\n                g1.drawLine(43+i*25, 60, 43+i*25, 375+60);  //画棋盘竖线\n            }           \n                for(int i=0; i&#x3C;15; i++){\n                for (int j = 0; j &#x3C; 15; j++) {\n                    //画实心黑子\n                    if(allChess[i][j] == 1){    \n                        int tempX = i*25+47;\n                        int tempY = j*25+64;\n                        g1.setColor(Color.BLACK);\n                        g1.fillOval(tempX, tempY, 16, 16);\n                        g1.setColor(Color.BLACK);\n                        g1.drawOval(tempX, tempY, 16, 16);\n                    }\n                    //画实心白子\n                    if(allChess[i][j] == 2){\n                        int tempX = i*25+47;\n                        int tempY = j*25+64;\n                        g1.setColor(Color.WHITE);\n                        g1.fillOval(tempX, tempY, 16, 16);\n                        g1.setColor(Color.WHITE);\n                        g1.drawOval(tempX, tempY, 16, 16);\n                    }\n                }\n            }           \n             g.drawImage(buf, 0, 0,this);   \n    }\n</code></pre>\n<p><strong>鼠标监听器</strong></p>\n<pre><code>    public void mousePressed(MouseEvent e){\n        if(canPlay){\n            x=e.getX();\n            y=e.getY();  // 用来获取鼠标坐标\n            if(x>55 &#x26;&#x26; x&#x3C;= 405  &#x26;&#x26; y>=72 &#x26;&#x26; y&#x3C;=420){\n                //让鼠标在棋盘范围内\n                if((x-55)%25>12){\n                    x=(x-55)/25 + 1;\n                }else {\n                    x = (x-55)/25;\n                }\n                if((y-72)%25>12){\n                    y=(y-72)/25 + 1;\n                }else {\n                    y=(y-72)/25;\n                }   \n                //落子\n                if(allChess[x][y] == 0){\n                    chessX[countX++] = x;\n                    chessY[countY++] = y;\n                    if(isblack){\n                        allChess[x][y] = 1;\n                        isblack = false;\n                    }else {\n                        allChess[x][y] = 2;\n                        isblack = true;         \n                    }\n                    this.repaint();     \n                    if(this.isWin()){\n                        if(allChess[x][y] == 1){\n                            JOptionPane.showMessageDialog(this, \"游戏结束，黑方胜利\");\n                        }else {\n                            JOptionPane.showMessageDialog(this, \"游戏结束，白方胜利\");\n                        }\n                        this.canPlay = false;  //表示游戏结束\n                    }           \n                }\n            }\n        }       \n    }\n</code></pre>\n<p><strong>判断方向</strong></p>\n<pre><code>    public boolean isWin(){\n        boolean flag = false;\n        int count = 1;  //用来保存共有相同颜色多少棋子相连，初始值为1\n        int color = allChess[x][y];  //color = 1 (黑子) color = 2(白子)\n        \n        //判断横向是否有5个棋子相连，特点:纵坐标是相同，即allChess[x][y] 中y值是相同\n        count = this.checkCount(1,0,color);\n        if(count >= 5){\n            flag = true;\n        }else {\n            //判断纵向\n            count = this.checkCount(0,1,color);\n            if(count >= 5){\n                flag = true;\n            }else {\n                 //判断右上,左下\n                count = this.checkCount(1,-1,color);\n                if(count >= 5){\n                    flag = true;\n                }else {\n                    //判断右下,左上\n                    count = this.checkCount(1,1,color);\n                    if(count >= 5){\n                        flag =  true;\n                    }\n                }\n            }\n        }\n        \n        return flag;\n    }\n</code></pre>\n<p><strong>判断一个五子连线</strong></p>\n<pre><code>    public int checkCount(int xChange , int yChenge ,int color){\n        int count = 1;\n        int tempX = xChange;\n        int tempy = yChenge;  //保存初始值   \n        //全局变量x,y最初为鼠标点击的坐标，\n        //经下棋方法已经x,y的将范围变成0-15(遍历整个棋盘,寻找相同颜色的棋子)\n        while(x + xChange >=0 &#x26;&#x26; x+xChange &#x3C;15  &#x26;&#x26; y+yChenge >=0 &#x26;&#x26; y+yChenge &#x3C; 15 &#x26;&#x26; color == allChess[x+xChange][y+yChenge]){\n            count++;\n            if(xChange != 0)  xChange++;    \n            if(yChenge != 0 ){      \n                if(yChenge != 0){\n                    if(yChenge > 0) {   \n                        yChenge++;      \n                    }else {\n                        yChenge--;      \n                    }\n                }\n            }           \n        }       \n        xChange = tempX;\n        yChenge = tempy;   // 恢复初始值             \n        while(x-xChange >=0 &#x26;&#x26; x-xChange &#x3C;15 &#x26;&#x26; y-yChenge >=0 &#x26;&#x26;\n                y-yChenge &#x3C;15 &#x26;&#x26; color == allChess[x-xChange][y-yChenge]){      \n            count++;\n            if(xChange != 0){\n                xChange++;\n            }\n            if(yChenge != 0){\n                if (yChenge > 0) {\n                    yChenge++;          \n                }else {\n                    yChenge--;          \n                }\n            }\n        }       \n        return count;\n    }       \n</code></pre>\n<pre><code>package 模拟练习.五子棋;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport java.awt.*;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.image.BufferedImage;\npublic  class FiveGame extends JFrame implements MouseListener{\n    int width = Toolkit.getDefaultToolkit().getScreenSize().width;\n    int height = Toolkit.getDefaultToolkit().getScreenSize().height;\n    int x,y;  // 定义鼠标的坐标\n    int[][] allChess = new int[15][15];   // 用数组来保存棋子，0表示无子，1表示黑子，2表示白子\n    boolean isblack = true;   //用来表示黑子还是白子， true表示黑子   false表示白子\n    boolean canPlay = true;   // 用来表示当前游戏是否结束\n    \n    int[] chessX = new int[255];\n    int[] chessY = new int[255];\n    int countX,countY;\n        \n    public FiveGame(){\n        this.setTitle(\"五子棋1.0\");\n        this.setSize(500,500);\n        this.setLocation((width - 500) / 2 , (height - 500) / 2 );\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setResizable(false);  //设置窗口不可改变，固定窗口大小\n        this.setVisible(true);\n        \n        this.repaint();  //java里repaint()是重绘component的方法；\n        this.addMouseListener(this);        \n    }\n    public void paint(Graphics g){\n        BufferedImage buf = new BufferedImage(500, 500, BufferedImage.TYPE_INT_RGB);\n        Graphics g1 =  buf.createGraphics();  // 创建画笔\n        g1.setColor(new Color(135,206,250));\n        g1.fill3DRect(43, 60, 375, 375, true);\n            for (int i = 0; i &#x3C;= 15; i++) {\n                g1.setColor(Color.WHITE);\n                g1.drawLine(43, 60+i*25, 375+43, 60+i*25);  //画棋盘横线\n                g1.drawLine(43+i*25, 60, 43+i*25, 375+60);  //画棋盘竖线\n            }           \n                for(int i=0; i&#x3C;15; i++){\n                for (int j = 0; j &#x3C; 15; j++) {\n                    //画实心黑子\n                    if(allChess[i][j] == 1){    \n                        int tempX = i*25+47;\n                        int tempY = j*25+64;\n                        g1.setColor(Color.BLACK);\n                        g1.fillOval(tempX, tempY, 16, 16);\n                        g1.setColor(Color.BLACK);\n                        g1.drawOval(tempX, tempY, 16, 16);\n                    }\n                    //画实心白子\n                    if(allChess[i][j] == 2){\n                        int tempX = i*25+47;\n                        int tempY = j*25+64;\n                        g1.setColor(Color.WHITE);\n                        g1.fillOval(tempX, tempY, 16, 16);\n                        g1.setColor(Color.WHITE);\n                        g1.drawOval(tempX, tempY, 16, 16);\n                    }\n                }\n            }           \n             g.drawImage(buf, 0, 0,this);   \n    }\n    public void mousePressed(MouseEvent e){\n        if(canPlay){\n            x=e.getX();\n            y=e.getY();  // 用来获取鼠标坐标\n            if(x>55 &#x26;&#x26; x&#x3C;= 405  &#x26;&#x26; y>=72 &#x26;&#x26; y&#x3C;=420){\n                //让鼠标在棋盘范围内\n                if((x-55)%25>12){\n                    x=(x-55)/25 + 1;\n                }else {\n                    x = (x-55)/25;\n                }\n                if((y-72)%25>12){\n                    y=(y-72)/25 + 1;\n                }else {\n                    y=(y-72)/25;\n                }   \n                //落子\n                if(allChess[x][y] == 0){\n                    chessX[countX++] = x;\n                    chessY[countY++] = y;\n                    if(isblack){\n                        allChess[x][y] = 1;\n                        isblack = false;\n                    }else {\n                        allChess[x][y] = 2;\n                        isblack = true;         \n                    }\n                    this.repaint();     \n                    if(this.isWin()){\n                        if(allChess[x][y] == 1){\n                            JOptionPane.showMessageDialog(this, \"游戏结束，黑方胜利\");\n                        }else {\n                            JOptionPane.showMessageDialog(this, \"游戏结束，白方胜利\");\n                        }\n                        this.canPlay = false;  //表示游戏结束\n                    }           \n                }\n            }\n        }       \n    }\n    public boolean isWin(){\n        boolean flag = false;\n        int count = 1;  //用来保存共有相同颜色多少棋子相连，初始值为1\n        int color = allChess[x][y];  //color = 1 (黑子) color = 2(白子)\n        \n        //判断横向是否有5个棋子相连，特点:纵坐标是相同，即allChess[x][y] 中y值是相同\n        count = this.checkCount(1,0,color);\n        if(count >= 5){\n            flag = true;\n        }else {\n            //判断纵向\n            count = this.checkCount(0,1,color);\n            if(count >= 5){\n                flag = true;\n            }else {\n                 //判断右上,左下\n                count = this.checkCount(1,-1,color);\n                if(count >= 5){\n                    flag = true;\n                }else {\n                    //判断右下,左上\n                    count = this.checkCount(1,1,color);\n                    if(count >= 5){\n                        flag =  true;\n                    }\n                }\n            }\n        }\n        \n        return flag;\n    }\n    public int checkCount(int xChange , int yChenge ,int color){\n        int count = 1;\n        int tempX = xChange;\n        int tempy = yChenge;  //保存初始值   \n        //全局变量x,y最初为鼠标点击的坐标，\n        //经下棋方法已经x,y的将范围变成0-15(遍历整个棋盘,寻找相同颜色的棋子)\n        while(x + xChange >=0 &#x26;&#x26; x+xChange &#x3C;15  &#x26;&#x26; y+yChenge >=0 &#x26;&#x26; y+yChenge &#x3C; 15 &#x26;&#x26; color == allChess[x+xChange][y+yChenge]){\n            count++;\n            if(xChange != 0)  xChange++;    \n            if(yChenge != 0 ){      \n                if(yChenge != 0){\n                    if(yChenge > 0) {   \n                        yChenge++;      \n                    }else {\n                        yChenge--;      \n                    }\n                }\n            }           \n        }       \n        xChange = tempX;\n        yChenge = tempy;   // 恢复初始值             \n        while(x-xChange >=0 &#x26;&#x26; x-xChange &#x3C;15 &#x26;&#x26; y-yChenge >=0 &#x26;&#x26;\n                y-yChenge &#x3C;15 &#x26;&#x26; color == allChess[x-xChange][y-yChenge]){      \n            count++;\n            if(xChange != 0){\n                xChange++;\n            }\n            if(yChenge != 0){\n                if (yChenge > 0) {\n                    yChenge++;          \n                }else {\n                    yChenge--;          \n                }\n            }\n        }       \n        return count;\n    }       \n    public void mouseClicked(MouseEvent e) {\n        // TODO Auto-generated method stub\n        \n    }\n    public void mouseReleased(MouseEvent e) {\n        // TODO Auto-generated method stub\n    }\n    public void mouseEntered(MouseEvent e) {\n        // TODO Auto-generated method stub\n    }\n    public void mouseExited(MouseEvent e) {\n        // TODO Auto-generated method stub      \n    }   \n    public static void main(String[] args) {\n        new FiveGame();\n    }   \n}\n</code></pre>","excerpt":"五子棋 主方法 FiveGame 画棋盘 鼠标监听器 判断方向 判断一个五子连线","fields":{"tagSlugs":["/tags/java/"]},"frontmatter":{"title":"Java-五子棋","tags":["Java"],"date":"May 04, 2019"}}},"pageContext":{"slug":"/java-five/"}}}